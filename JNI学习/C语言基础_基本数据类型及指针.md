##c语言学习基础

###1. 基本数据类型
> 1. 基本数据类型
>   ![](D:\learn\LearningSchedule\C\基本数据类型.jpg)
> 2. 在C/C++中没有String类型；
> 3. 在C/C++中分平台，在不同的平台下基本数据类型所占的字节稍显不同，目前主要使用的32位和64位的系统，其中long类型的所占的字节数不同，在32位中占4个字节，64位中占8个字节；
> 4. 在C/C++中多几个基本数据类型，比如：singned和unsigned类型，这两个表示无符号和有符号的数据类型，其中我们平时使用的就是有符号的数据类型，而相对于无符号的数据类型所占的内存是从0开始的也就是从正数开始的，而有符号的是从负数开始的；
> 5. 对于long long数据类型的解释：long和int在早期16位电脑时候 int 2字节，long 4字节，而计算机发展到现在，一般32、64下，long和int一样。和java类比的话，java的long就是 long long 8字节；
> 6. long 和long long 的区别？ 这个在不同的平台和不同的编译器上面是长度是不一样的，主要考虑到数据的兼容性，在C/C++设计中主要考虑了sizeof(short)<=sizeof(int)<=sizeof(long)<=sizeof(long long) 为保证程序在不同平台取值占位一致性所以在后续的程序使用中尽量int64_t和int32_t来确定变量的占位；
> 7. int64_t 就是long long类型的，就是在32位和64位系统中占8位，而int32_t 就是int类型的就是4个字节
> 8. 在32位系统中：char是占1个字节，short 是占2个字节，int，float，long是占4个字节的，double是占8个字节的，指针是4位的这个与java中有很大的区别，在java中，byte 和boolen值占1个字节，short和char是2个字节，int和float是4个，long和double是8个

###2. 数组的定义
1. > 对于数组的声明必须是要申明数组的长度或者初始化数组的值；
   >

   ```
   	`int arr[10];`
   	`int arr[]={1,2,3}`
   ```

   

###3. 格式化输出
1. > 在java中封装了这部分的格式数据，比如打印的时候传入的都是string类型，而在C/C++中并未做封装，需要自己写，其实这种情况和String.format()类似，都是需要先指定输入的参数的；
   >

   ```
   	`%d 十进制有符号整数` 
   	%u 十进制无符号整数
   	%f 浮点数
   	%s 字符串
   	%c 单个字符
   	%p 指针的值
   	%e 指数形式的浮点数
   	%x, %X 无符号以十六进制表示的整数
   	% 0 无符号以八进制表示的整数
   	`%g 自动选择合适的表示法`
   ```

   
###4. 内存申请
1. > 首先搞清楚那些数据是存放在堆内存那些数据是存放在栈内存的？
  > 1. 对于局部成员变量或者方法是要入栈的，这部分数据是要存放在栈内存中的
  > 2. 其次，栈的内存是很小的，不可申请过大的内存否则会出现我们常见的stackOverFlow
  > 3. 对于堆内存中存放的是动态申请的或者new出来的对象

2. > 常见的内存申请的方式：

   1. 堆内存申请并赋初值，利用malloc方式

      ```
      int *l=(int*)malloc(1 * 1024 * 1024);
      	memset(l, 0, sizeof(l));
      	//对于条件判断语句，非0即true，非null即true
      	if (l)
      	{
      		printf("%s\n", "malloc申请内存并讲内存置为null");
      	}
      ```

   2. 堆内存申请并默认赋初值为null，利用calloc方式

      ​	

      ```
      //在堆内存中申请控件并初始化为null
      	int *o=(int*)calloc(10, sizeof(int));
      	if (o)
      	{
      		printf("%s\n", "calloc申请内存并讲内存置为null");
      	}
      ```

   3. 堆内存修改申请内存的大小

      	realloc函数调用是有问题的，这个会触发断点
      	int * y=(int*)realloc(o, 1 * 1024);
      	if (y)
      	{
      		printf("%s\n", "realloc申请内存并讲内存置为1 * 1024");
      	}

   4. >   **alloca** 在栈申请内存 

   ```
   int *p = (int *)alloca(sizeof(int) * 10); 
   ```

   

###5. 指针

> 指针是一个变量，其值为地址。
>
> 声明指针或者不使用都要将指针置为NULL或者0；
>
> 野指针：就是定义了未被初始化的指针就是野指针；
>
> 悬空指针：就是指针指向的内存已经被释放了，那么这样的指针就是悬空指针

```
int *a; 正规
int* a;
int * a;
//因为 其他写法看起来有歧义
int* a,b;
```

使用

```
//声明一个整型变量
int i = 10;
//将i的地址使用取地址符给p指针
int *p = &i;
//输出 0xffff 16进制地址
printf("%#x\n", &i);
printf("%#x\n", &p);
```

> 指针多少个字节？指向地址，存放的是地址 
>
> 地址在 32位中指针占用4字节 64位占8字节

```
//32位：
sizeof(p) == 4;
//64位:
sizeof(p) == 8;
```

解引用

> 解析并返回内存地址中保存的值 

```
int i = 10;
int *p = &i;
//解引用  
//p指向一个内存地址，使用*解出这个地址的值 即为 10
int pv = *p;
//修改地址的值,则i值也变成100
//为解引用的指针赋值也是为指针所指的内存赋值，方便操作一块内存
*p = 100;
```

指针运算

```
//对指针 进行算数运算
//数组是一块连续内存 分别保存 11-55
//*p1 指向第一个数据 11，移动指针就指向第二个了
int i1[] = {11,22,33,44,55};
int *p1 = i1;
for (size_t i = 0; i < 5; i++)
{
    //自增++ 运算符比 解引用* 高,但++在后为先用后加
    //如果++在前则输出 22-55+xx
	printf("%d\n", *p1++);
	//printf("%d\n", p1[i]);
    //p1[0] == *(p1+1) == s[1]

}
```

> 指针指向地址，指针运算实际上就是移动指针指向的地址位置,移动的位数取决于指针类型（int就是32位）

###6. 数组指针和指针数组

####1. 数组指针

> 在c语言中，指针和数组名都表示地址
>
> 1、数组是一块内存连续的数据。 
>
> 2、指针是一个指向内存空间的变量 

1. 理解：顾名思义就是指针，数组指针就是数组的指针，就是指向数组的指针，

2. 举例说明：

    ```
    int (*p)[10];
    char (*p1)[10];
    ```

    > 
    > 那么int *p[4]和int (*p)[4]的区别是什么？
    > 区别：由上面可知是指针，是指向一个大小为10个整形数据的指针，这个地方设计的运算符的优先级，[]和（）的优先级相同，但是比*的优先级要高，所以int (*p)[10]先会取（*p）这个就是指针了，然后和[]结合，就是数组指针，就是指向数组的指针；
    > 	

    ```
    //数组指针
    //二维数组类型是 int (*p)[x]
    int array[2][3] = { {11,22,33},{44,55,66} };
    //也可以 int array[2][3] = {  11,22,33 ,44,55,66 };
    //array1 就是一个 int[3] 类型的指针
    int (*array1)[3] = array;
    //怎么取 55 ？
    //通过下标
    array[1][1] == array1[1][1]
    //通过解引用
    int i = *(*(array1 + 1) + 1);
    //拆分
    //1、 指针偏移 因为array1的类型是3个int的数组 所以 +1 移动了12位
    array1 + 1 
    //2、获得{44,55,66}数组  (*(array1 + 1))[1] = 55
    (*(array1 + 1) 
    //3、对数组执行 +/- 相当于隐式的转为指针
    //获得 55 的地址 再解地址
    *(array1 + 1) + 1
    ```

    
####2. 指针数组
1. 理解：顾名思义就是数组，就是指针的数组，就是存放指针的数组；

2. 举例说明：

   ```
   int *p[10];
   同上解释这个数组就是存放int *的数据，所以就是指针数组；
   int arry[5]
   ```

   
   ​	对于arry和&arry是指的什么？
   	arry指的是取这个arry这个数组的首地址而&arry指的是取arry这个数组的地址；

###7.函数指针与指针函数

> C中的函数与java没有区别。都是一组一起执行一个任务的语句，也都由 **函数头**与**函数体**构成

##### 函数参数

##### 传值调用

> ​		把参数的值复制给函数的形式参数。修改形参不会影响实参

##### 引用调用

> ​		形参为指向实参地址的指针，可以通过指针修改实参

```
void change1(int i) {
	i = 10;
}
void change2(int *i) {
	*i = 10;
}
int i = 1;
change1(i);
printf("%d\n",i); //i == 1
change2(&i);
printf("%d\n",i); //i == 10
```

##### 可变参数

> 与Java一样，C当中也有可变参数



```
include <stdarg.h>

int add(int num, ...)
{
	va_list valist;
	int sum = 0;
	// 初始化  valist指向第一个可变参数 (...)
	va_start(valist, num);
	for (size_t i = 0; i < num; i++)
	{
		//访问所有赋给 valist 的参数
		int j = va_arg(valist, int);
		printf("%d\n", j);
		sum += j;
	}
	//清理为 valist 内存
	va_end(valist);
	return sum;
}
```



#####函数指针

> 函数指针是指向函数的指针变量

#####指针函数



### 8.预处理器

> 预处理器不是编译器，但是它是编译过程中一个单独的步骤。
>
> 预处理器是一个文本替换工具
>
> 所有的预处理器命令都是以井号（#）开头

常用预处理器

| 预处理器 | 说明         |
| -------- | ------------ |
| #include | 导入头文件   |
| #if      | if           |
| #elif    | else if      |
| #else    | else         |
| #endif   | 结束 if      |
| #define  | 宏定义       |
| #ifdef   | 如果定义了宏 |
| #ifndef  | 如果未定义宏 |
| #undef   | 取消宏定义   |

#### 宏

**预处理器是一个文本替换工具**

宏就是文本替换



```
//宏一般使用大写区分
//宏变量
//在代码中使用 A 就会被替换为1

# define A 1

//宏函数

# defind test(i) i > 10 ? 1: 0

//其他技巧
// # 连接符 连接两个符号组成新符号

# define DN_INT(arg) int dn_ ## arg

DN_INT(i) = 10;
dn_i = 100;

// \ 换行符，定义宏的时候换行需要用到

# define PRINT_I(arg) if(arg) { \

 printf("%d\n",arg); \
 }
PRINT_I(dn_i);

//可变宏，最常见的在JNI开发的过程中定义可变参数，打印日志

# define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,"NDK", __VA_ARGS__);

//陷阱，宏只会做替换，按照这种方式定义，则调用的时候注意：MULTI(100+10，11+2)；这样调用时会出现错误的结果就会变成100+10*11+2，不会出现我们预料的结果；、

# define MULTI(x,y)  x*y

//获得 4
printf("%d\n", MULTI(2, 2));
//获得 1+1*2  = 3
printf("%d\n", MULTI(1+1, 2));
```

> 宏函数
>
> ​	优点：
>
> ​		文本替换，每个使用到的地方都会替换为宏定义。
>
> ​		不会造成函数调用的开销（开辟栈空间，记录返回地址，将形参压栈，从函数返回还要释放堆		
>
> ​		栈。）
>
> ​	缺点：
>
> ​		生成的目标文件大，不会执行代码检查
>
> 
>
> 内联函数
>
> ​	和宏函数工作模式相似，但是两个不同的概念，首先是函数，那么就会有类型检查同时也可以debug
> 在编译时候将内联函数插入。
>
> 不能包含复杂的控制语句，while、switch，并且内联函数本身不能直接调用自身。
> 如果内联函数的函数体过大，编译器会自动的把这个内联函数变成普通函数。